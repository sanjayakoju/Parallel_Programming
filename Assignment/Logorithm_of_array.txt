 # Logorithm

// ConsoleApplication1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <omp.h>
#include <math.h>
#define size 10000
int i, a[size];
clock_t t;

int main()
{
    t = clock();
    omp_set_num_threads(10); 
    #pragma omp parallel for
        for (i = 0; i < size;i++) {
            a[i] = rand()%100;
            double b = log(a[i]);
            double sqr = sqrt(a[i]);
            double sqrt = sin(a[i]);
            printf("Logorithm of %d is : %lf\n", a[i], b);
            printf("Square of %d is : %lf\n", a[i], sqr);
            printf("Sin of %d is : %lf\n", a[i], sqrt);
        
        }

    printf("Elapsed Time: %d\n", clock() - t);
    
return 0;
}

Determine the execution time for total number of 
threads from 1 to 10
Thread    Execution Time
1         10498
2		  8547
3		  8755
4         8424
5         8513
6         8354
7         8867
8         8508
9         8845
10        8376

 Explain the reason why additional threads sometimes do not reduce the execution time.
 As you correctly pointed out, adding more threads doesn't boost performance capacity;
 instead, it makes the kernel work harder, which uses up more CPU time. In essence, threading
 has decreasing rewards, and doing too much degrades performance.
 