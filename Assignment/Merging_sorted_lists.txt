#Merge Array
 
 // SortArray.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <omp.h>
#include <math.h>
#define n 4000
int i,x[n], y[n],z[2*n];
clock_t t;
int main()
{
    t = clock();
    int c[sizeof(n) + sizeof(n)];
    omp_set_num_threads(10);
#pragma omp parallel for
    for (i = 0;i < n;i++) {
        x[i] = i * 2;
        y[i] = 2 * i + 1;
    }
    for (i = 0;i < n;i++) {
        z[i] = x[i];
        printf("Z index %d is : %d\n ", i, z[i]);
    }
    for (i = n;i < n*2;i++) {
        z[i] = y[i];
        printf("Z index %d is : %d\n ", i, z[i]);
    }

    printf("Elapsed Time: %d\n", clock() - t);
}

Determine the execution time for total number of 
threads from 1 to 10
Thread    Execution Time
1         4954
2		  5008
3		  5072
4         5172
5         5010
6         5014
7         5086
8         4959
9         5041
10        5015

 Explain the reason why additional threads sometimes do not reduce the execution time.
 As you correctly pointed out, adding more threads doesn't boost performance capacity;
 instead, it makes the kernel work harder, which uses up more CPU time. In essence, threading
 has decreasing rewards, and doing too much degrades performance.